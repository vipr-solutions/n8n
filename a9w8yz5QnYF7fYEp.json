{
  "createdAt": "2025-11-26T15:26:32.417Z",
  "updatedAt": "2025-12-01T08:28:42.706Z",
  "id": "a9w8yz5QnYF7fYEp",
  "name": "Exporting from Intarga",
  "active": false,
  "nodes": [
    {
      "parameters": {
        "formTitle": "File",
        "formFields": {
          "values": [
            {
              "fieldLabel": "File",
              "fieldType": "file"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2.2,
      "position": [
        0,
        0
      ],
      "id": "4163fe67-465d-421f-b82b-8e4032ba23b1",
      "name": "On form submission",
      "webhookId": "c83aec86-187f-422c-a236-16bdee44c81a"
    },
    {
      "parameters": {
        "jsCode": "// Mode: Run Once for All Items\n// Language: JavaScript\n\n// 1) Get the uploaded file from the incoming item\nconst item = $input.item;\nconst binary = item.binary || {};\n\nconst binaryKeys = Object.keys(binary);\nif (binaryKeys.length === 0) {\n  throw new Error('No binary data found on this item. Check the \"Binary\" tab of the input to see the file key.');\n}\n\n// Use the first binary key (usually the file upload field)\nconst binKey = binaryKeys[0];\n\n// 2) Decode and parse the Intarga export JSON\nconst raw = Buffer.from(binary[binKey].data, 'base64').toString('utf8');\nconst json = JSON.parse(raw);\n\n// 3) Build nodes (with attributes) and edges (correct links)\nconst tasks = json.Editor?.Tasks || [];\n\nconst nodes = [];\nconst edges = [];\nconst seenEdges = new Set(); // avoid duplicates\n\n// Helper: build a human-readable condition/label for a connection\nfunction buildConnectionLabel(conn) {\n  const parts = [];\n\n  // 1) Existing response text (Yes/No/Success/Fail etc.)\n  if (conn.Response) {\n    parts.push(String(conn.Response));\n  }\n\n  // 2) Try to include workflow condition details, if present\n  // Adjust this to match your actual JSON structure if needed.\n  let condText = \"\";\n\n  // Case A: simple string property, e.g. \"WorkflowCondition\": \"Status = Complete\"\n  if (conn.WorkflowCondition && typeof conn.WorkflowCondition === \"string\") {\n    condText = conn.WorkflowCondition;\n  }\n\n  // Case B: object with a \"Description\" or \"Display\" etc.\n  if (!condText && conn.WorkflowCondition && typeof conn.WorkflowCondition === \"object\") {\n    condText =\n      conn.WorkflowCondition.Description ||\n      conn.WorkflowCondition.DisplayText ||\n      conn.WorkflowCondition.Text ||\n      \"\";\n  }\n\n  // Case C: array of conditions\n  if (!condText && Array.isArray(conn.WorkflowConditions)) {\n    condText = conn.WorkflowConditions\n      .map(c => {\n        if (!c) return \"\";\n        return (\n          c.Description ||\n          c.DisplayText ||\n          c.Text ||\n          `${c.AttributeName || c.Field || \"\"} ${c.Operator || \"\"} ${c.Value || \"\"}`.trim()\n        );\n      })\n      .filter(s => s && s.trim() !== \"\")\n      .join(\" AND \");\n  }\n\n  if (!condText && conn.Condition) {\n    // generic fallback if there's a \"Condition\" field\n    if (typeof conn.Condition === \"string\") {\n      condText = conn.Condition;\n    } else if (typeof conn.Condition === \"object\") {\n      condText =\n        conn.Condition.Description ||\n        conn.Condition.DisplayText ||\n        conn.Condition.Text ||\n        \"\";\n    }\n  }\n\n  if (condText) {\n    parts.push(String(condText));\n  }\n\n  // Combine: \"Yes – PolicyStatus = 'Bound'\"\n  return parts.join(\" – \");\n}\n\nfor (const t of tasks) {\n  const id = String(t.TaskId);\n\n  // ---- Build label text (title + action type + attributes + ActionDelegates) ----\n  const props = [];\n\n  // Entity properties (your attribute fields)\n  (t.EntityProperties || []).forEach(ep => {\n    const dt = ep.DataType ? ` (${ep.DataType})` : '';\n    props.push(`${ep.DisplayName}${dt}`);\n  });\n\n  // Readonly properties\n  (t.ReadonlyProperties || []).forEach(rp => {\n    const dt = rp.DataType ? ` (${rp.DataType})` : '';\n    props.push(`(ro) ${rp.DisplayName}${dt}`);\n  });\n\n  // Try to turn ActionDelegates into a readable string\n  let actionDelegatesText = \"\";\n  const ad = t.ActionDelegates;\n\n  if (ad) {\n    if (Array.isArray(ad)) {\n      actionDelegatesText = ad\n        .map(d => {\n          if (!d) return \"\";\n          return (\n            d.Name ||\n            d.DisplayName ||\n            d.UserName ||\n            String(d)\n          );\n        })\n        .filter(s => s && s.trim() !== \"\")\n        .join(\", \");\n    } else {\n      actionDelegatesText = String(ad);\n    }\n  }\n\n  const lines = [];\n  if (t.Title) lines.push(t.Title);                          // task title\n  if (t.ActionType?.Value) lines.push(`[${t.ActionType.Value}]`); // e.g. [Update]\n  if (actionDelegatesText) lines.push(`ActionDelegates: ${actionDelegatesText}`);\n  if (props.length) lines.push(...props.map(p => `• ${p}`));      // attributes\n\n  nodes.push({\n    id,\n    label: lines.join('\\n'),\n    ActionDelegates: actionDelegatesText,\n    x: (t.ClientData?.Left ?? 0) + 100,\n    y: (t.ClientData?.Top ?? 0) + 100,\n  });\n\n  // ---- Build edges from parent → current, plus any ResponseTaskId links ----\n  const conns = t.Connections || [];\n\n  conns.forEach((c, idx) => {\n    const label = buildConnectionLabel(c); // <<-- includes workflow condition text where possible\n\n    // Case 1: ParentTaskClientId like \"task-171\" -> edge 171 → current TaskId\n    const parentKey = c.ParentTaskClientId;\n    if (typeof parentKey === 'string' && parentKey.startsWith('task-')) {\n      const parentId = parentKey.split('-')[1]; // \"task-171\" -> \"171\"\n      const edgeKey = `${parentId}->${id}`;\n\n      if (!seenEdges.has(edgeKey)) {\n        edges.push({\n          id: `p_${parentId}_${id}_${idx}`,\n          from: parentId,\n          to: id,\n          label, // condition + response\n        });\n        seenEdges.add(edgeKey);\n      }\n    }\n\n    // Case 2: explicit ResponseTaskId (if non-zero) -> edge current → ResponseTaskId\n    const respId = c.ResponseTaskId || 0;\n    if (respId) {\n      const childId = String(respId);\n      const edgeKey = `${id}->${childId}`;\n\n      if (!seenEdges.has(edgeKey)) {\n        edges.push({\n          id: `c_${id}_${childId}_${idx}`,\n          from: id,\n          to: childId,\n          label, // condition + response\n        });\n        seenEdges.add(edgeKey);\n      }\n    }\n  });\n}\n\n// 4) Return for the XML generator node\nreturn [\n  {\n    json: {\n      nodes,\n      edges,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        220,
        0
      ],
      "id": "a591c77c-52c6-429d-b3c7-7649535f78f5",
      "name": "Code"
    },
    {
      "parameters": {
        "jsCode": "// ---------------------------------------------------------\n// Expected input JSON (from previous node):\n// {\n//   \"nodes\": [{\n//     id,\n//     label,           // multi-line string built in first node\n//     ActionDelegates, // string, e.g. \"Alice, Bob\"\n//   }],\n//   \"edges\": [{ from, to, label }]\n// }\n// ---------------------------------------------------------\n\nconst item = $input.item;\nconst data = item.json || {};\nconst nodes = data.nodes || [];\nconst edges = data.edges || [];\n\n// Early exit if nothing\nif (!Array.isArray(nodes) || nodes.length === 0) {\n  return [\n    {\n      json: data,\n    },\n  ];\n}\n\n// ---------------------------------------------------------\n// Helpers\n// ---------------------------------------------------------\nfunction esc(str) {\n  return String(str || \"\")\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&apos;\");\n}\n\n// Extract action type from label lines, e.g. \"[Update]\" -> \"Update\"\nfunction getActionTypeFromLines(lines) {\n  for (let i = 0; i < lines.length; i++) {\n    const m = lines[i].match(/^\\[(.+?)\\]\\s*$/);\n    if (m) {\n      return m[1].trim();\n    }\n  }\n  return \"\";\n}\n\n// Map action type to header colour\nfunction getHeaderColor(actionType) {\n  const t = String(actionType || \"\").toLowerCase();\n\n  // Triggered events → purple\n  if (t.includes(\"trigger\")) {\n    return \"#e0c9ff\"; // purple-ish\n  }\n\n  // System Email → blue\n  if (t === \"system email\" || t === \"systememail\") {\n    return \"#cfe8ff\";\n  }\n\n  // User actionable → pink\n  if ([\"create\", \"update\", \"review\", \"no action\", \"noaction\"].includes(t)) {\n    return \"#ffd6f2\";\n  }\n\n  // default grey\n  return \"#f0f0f0\";\n}\n\n// ---------------------------------------------------------\n// Normalise IDs so all edges resolve\n// ---------------------------------------------------------\nconst idMap = {};       // logical node id (string) -> [mxCellId,...]\nconst nodeCellIds = []; // index -> mxCellId\n\nnodes.forEach((node, idx) => {\n  const mxId = \"task_\" + idx;\n  nodeCellIds[idx] = mxId;\n\n  const key = String(node.id);\n  if (!idMap[key]) {\n    idMap[key] = [];\n  }\n  idMap[key].push(mxId);\n});\n\nfunction resolve(id) {\n  const key = String(id);\n  const arr = idMap[key];\n  if (!arr || arr.length === 0) return null;\n  return arr[0];\n}\n\n// Quick lookup for nodes by id\nconst nodeById = {};\nnodes.forEach((n) => {\n  nodeById[String(n.id)] = n;\n});\n\n// ---------------------------------------------------------\n// Build graph structure for layout\n// ---------------------------------------------------------\nconst incoming = {};\nconst children = {};\nconst parents = {};\nconst levelMap = {};\n\nnodes.forEach((n) => {\n  incoming[n.id] = 0;\n  children[n.id] = [];\n  parents[n.id] = [];\n});\n\nedges.forEach((e) => {\n  if (incoming[e.to] !== undefined) {\n    incoming[e.to] += 1;\n  }\n  if (children[e.from]) {\n    children[e.from].push(e.to);\n  }\n  if (parents[e.to]) {\n    parents[e.to].push(e.from);\n  }\n});\n\n// ---------------------------------------------------------\n// Level assignment (top-down, cycle-safe)\n// ---------------------------------------------------------\nlet queue = nodes.filter((n) => incoming[n.id] === 0).map((n) => n.id);\n\n// If no clear roots, treat all as level 0\nif (queue.length === 0) {\n  queue = nodes.map((n) => n.id);\n}\n\nqueue.forEach((id) => {\n  levelMap[id] = 0;\n});\n\n// assign each child only once → no infinite loops on cyclic graphs\nwhile (queue.length > 0) {\n  const newQ = [];\n  for (let i = 0; i < queue.length; i++) {\n    const id = queue[i];\n    const lvl = levelMap[id];\n    const kids = children[id] || [];\n    for (let j = 0; j < kids.length; j++) {\n      const c = kids[j];\n      const current = levelMap[c];\n      if (current === undefined) {\n        levelMap[c] = lvl + 1;\n        newQ.push(c);\n      }\n    }\n  }\n  queue = newQ;\n}\n\n// Group nodes by level\nconst levels = {};\nnodes.forEach((n) => {\n  const lvl = levelMap[n.id] !== undefined ? levelMap[n.id] : 0;\n  if (!levels[lvl]) {\n    levels[lvl] = [];\n  }\n  levels[lvl].push(n);\n});\n\n// ---------------------------------------------------------\n// Positioning (more spacing, simple layered layout)\n// ---------------------------------------------------------\nconst nodeWidth = 240;\nconst baseHeight = 140;\n\n// Bigger gaps to give the router space to go AROUND nodes\nconst verticalGap = 340;\nconst horizontalGap = 380;\n\nconst nodePositions = {};   // node.id -> {x,y}\nconst levelIndices = {};    // level -> { nodeId -> indexWithinLevel }\n\nconst levelKeys = Object.keys(levels)\n  .map((l) => parseInt(l, 10))\n  .sort((a, b) => a - b);\n\n// Decide ordering in each level (barycenter-ish)\nlevelKeys.forEach((level, levelIdx) => {\n  const levelNodes = levels[level];\n\n  if (levelIdx === 0) {\n    // Root level: stable logical order\n    levelNodes.sort((a, b) => String(a.id).localeCompare(String(b.id)));\n  } else {\n    const prevLevel = levelKeys[levelIdx - 1];\n    const prevNodes = levels[prevLevel] || [];\n\n    const prevPos = {};\n    prevNodes.forEach((n, idx) => {\n      prevPos[n.id] = idx;\n    });\n\n    levelNodes.sort((a, b) => {\n      function barycenter(node) {\n        const ps = parents[node.id] || [];\n        const positions = [];\n        for (let i = 0; i < ps.length; i++) {\n          const p = ps[i];\n          if (prevPos[p] !== undefined) {\n            positions.push(prevPos[p]);\n          }\n        }\n        if (positions.length === 0) return Number.POSITIVE_INFINITY;\n        let sum = 0;\n        for (let i = 0; i < positions.length; i++) sum += positions[i];\n        return sum / positions.length;\n      }\n\n      const ba = barycenter(a);\n      const bb = barycenter(b);\n\n      if (ba === bb) {\n        return String(a.id).localeCompare(String(b.id));\n      }\n      return ba - bb;\n    });\n  }\n\n  levelIndices[level] = {};\n  levelNodes.forEach((n, idx) => {\n    levelIndices[level][n.id] = idx;\n  });\n});\n\n// Assign actual positions\nlevelKeys.forEach((level) => {\n  const levelNodes = levels[level];\n  const count = levelNodes.length;\n  const totalWidth = (count - 1) * horizontalGap;\n  const startX = -totalWidth / 2;\n\n  levelNodes.forEach((n, i) => {\n    const x = startX + i * horizontalGap;\n    const y = level * verticalGap;\n    nodePositions[n.id] = { x, y };\n  });\n});\n\n// Shift everything right so nothing has negative x\nlet minX = Infinity;\nlet minY = Infinity;\nnodes.forEach((n) => {\n  const pos = nodePositions[n.id];\n  if (!pos) return;\n  if (pos.x < minX) minX = pos.x;\n  if (pos.y < minY) minY = pos.y;\n});\nconst offsetX = minX === Infinity || minX >= 20 ? 0 : 20 - minX;\n\nnodes.forEach((n) => {\n  const pos = nodePositions[n.id];\n  if (pos) {\n    pos.x += offsetX;\n  }\n});\n\n// recompute minY and maxRight after shifts\nminY = Infinity;\nlet maxRight = -Infinity;\nnodes.forEach((n) => {\n  const pos = nodePositions[n.id];\n  if (!pos) return;\n  if (pos.y < minY) minY = pos.y;\n  const right = pos.x + nodeWidth;\n  if (right > maxRight) maxRight = right;\n});\n\n// Compute right-hand side lane X for upward loops\nconst sideBaseX = maxRight + 100;\nconst sideLaneSpacing = 24;\nlet upwardEdgeCount = 0;\n\n// ---------------------------------------------------------\n// Build XML\n// ---------------------------------------------------------\nconst xmlParts = [];\n\nxmlParts.push(\n  '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n  '<mxfile host=\"n8n\">',\n  '  <diagram id=\"flow\" name=\"Workflow\">',\n  '    <mxGraphModel>',\n  '      <root>',\n  '        <mxCell id=\"0\"/>',\n  '        <mxCell id=\"1\" parent=\"0\"/>'\n);\n\n// ---------------------------------------------------------\n// Nodes (container + header with title bold, delegate normal, colour-coded)\n// ---------------------------------------------------------\nnodes.forEach((node, idx) => {\n  const mxId = nodeCellIds[idx];\n  const pos = nodePositions[node.id] || { x: 0, y: 0 };\n\n  // label from first node:\n  //   line 0: title\n  //   line 1: [ActionType]\n  //   maybe: ActionDelegates: ...\n  //   rest: • attributes\n  const rawLabel = String(node.label || String(node.id));\n  const lines = rawLabel.split(\"\\n\");\n\n  const titleLine = lines[0] || \"\";\n\n  // Extract action type from label\n  const actionType = getActionTypeFromLines(lines);\n  const headerColor = getHeaderColor(actionType);\n\n  // Try to get delegate from explicit property first\n  let delegateRaw = node.ActionDelegates || \"\";\n\n  // If no property, look for a line \"ActionDelegates: ...\"\n  let delegateLineIndex = -1;\n  if (!delegateRaw) {\n    for (let i = 0; i < lines.length; i++) {\n      const t = lines[i].trim();\n      if (/^ActionDelegates\\b/i.test(t)) {\n        delegateLineIndex = i;\n        const stripped = t.replace(/^ActionDelegates\\s*[:\\-]?\\s*/i, \"\");\n        delegateRaw = stripped.trim();\n        break;\n      }\n    }\n  }\n\n  // --- Build header: <b>Title</b> (Delegate1, Delegate2) ---\n  let headerRaw = `<b>${titleLine}</b>`;\n  if (delegateRaw) {\n    headerRaw += ` (${delegateRaw})`;\n  }\n  const headerValue = esc(headerRaw); // escape for XML (&lt;b&gt; etc)\n\n  // Body text: everything except\n  //  - first line (title)\n  //  - ActionDelegates line if found\n  const attrsLines = [];\n  for (let i = 1; i < lines.length; i++) {\n    if (i === delegateLineIndex) continue; // skip ActionDelegates line in body\n    attrsLines.push(lines[i]);\n  }\n  const attrsRaw = attrsLines.join(\"\\n\");\n  const attrsValue = esc(attrsRaw).replace(/\\n/g, \"&#xa;\");\n\n  // Parent container (group, collapsible)\n  xmlParts.push(\n    '        <mxCell id=\"' +\n      mxId +\n      '\" value=\"\" style=\"group;collapsible=1;foldable=1;rounded=1;container=1;whiteSpace=wrap;html=1;\" vertex=\"1\" parent=\"1\">',\n    '          <mxGeometry x=\"' +\n      pos.x +\n      '\" y=\"' +\n      pos.y +\n      '\" width=\"' +\n      nodeWidth +\n      '\" height=\"' +\n      baseHeight +\n      '\" as=\"geometry\"/>',\n    \"        </mxCell>\"\n  );\n\n  // Visible title header (title bold, delegate normal, colour-coded)\n  const headerStyle =\n    \"rounded=0;whiteSpace=wrap;html=1;align=center;verticalAlign=middle;fillColor=\" +\n    headerColor +\n    \";\";\n\n  xmlParts.push(\n    '        <mxCell id=\"' +\n      mxId +\n      '_header\" value=\"' +\n      headerValue +\n      '\" style=\"' +\n      headerStyle +\n      '\" vertex=\"1\" parent=\"' +\n      mxId +\n      '\">',\n    '          <mxGeometry x=\"0\" y=\"0\" width=\"' +\n      nodeWidth +\n      '\" height=\"40\" as=\"geometry\"/>',\n    \"        </mxCell>\"\n  );\n\n  // Attributes block\n  xmlParts.push(\n    '        <mxCell id=\"' +\n      mxId +\n      '_attrs\" value=\"' +\n      attrsValue +\n      '\" style=\"rounded=0;whiteSpace=wrap;html=1;overflow=fill;align=left;verticalAlign=top;\" vertex=\"1\" parent=\"' +\n      mxId +\n      '\">',\n    '          <mxGeometry x=\"0\" y=\"40\" width=\"' +\n      nodeWidth +\n      '\" height=\"' +\n      (baseHeight - 40) +\n      '\" as=\"geometry\"/>',\n    \"        </mxCell>\"\n  );\n});\n\n// ---------------------------------------------------------\n// Legend / Key (TOP LEFT of the workflow)\n// ---------------------------------------------------------\nconst legendX = 20;\nconst legendRowHeight = 26;\nconst legendRowGap = 4;\nconst legendWidth = 700;\n\n// Place legend slightly above top-most node (or at y=20 minimum)\nlet legendY = (minY === Infinity ? 20 : minY - 80);\nif (legendY < 20) legendY = 20;\n\n// Title: \"Key\"\nxmlParts.push(\n  '        <mxCell id=\"legend_title\" value=\"' +\n    esc(\"Key\") +\n    '\" style=\"text;whiteSpace=wrap;html=1;align=left;verticalAlign=top;fontStyle=1;\" vertex=\"1\" parent=\"1\">',\n  '          <mxGeometry x=\"' +\n    legendX +\n    '\" y=\"' +\n    legendY +\n    '\" width=\"' +\n    legendWidth +\n    '\" height=\"20\" as=\"geometry\"/>',\n  \"        </mxCell>\"\n);\n\n// Helper to calc row Y\nfunction legendRowY(rowIndex) {\n  return legendY + 24 + rowIndex * (legendRowHeight + legendRowGap);\n}\n\n// Row 0 – Blue: emails\nxmlParts.push(\n  '        <mxCell id=\"legend_blue\" value=\"' +\n    esc(\"Blue – Email tasks (System Email)\") +\n    '\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;fillColor=#cfe8ff;\" vertex=\"1\" parent=\"1\">',\n  '          <mxGeometry x=\"' +\n    legendX +\n    '\" y=\"' +\n    legendRowY(0) +\n    '\" width=\"' +\n    legendWidth +\n    '\" height=\"' +\n    legendRowHeight +\n    '\" as=\"geometry\"/>',\n  \"        </mxCell>\"\n);\n\n// Row 1 – Pink: user actionable\nxmlParts.push(\n  '        <mxCell id=\"legend_pink\" value=\"' +\n    esc(\"Pink – User actionable tasks in Intarga (Create, Update, Review, No Action)\") +\n    '\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;fillColor=#ffd6f2;\" vertex=\"1\" parent=\"1\">',\n  '          <mxGeometry x=\"' +\n    legendX +\n    '\" y=\"' +\n    legendRowY(1) +\n    '\" width=\"' +\n    legendWidth +\n    '\" height=\"' +\n    legendRowHeight +\n    '\" as=\"geometry\"/>',\n  \"        </mxCell>\"\n);\n\n// Row 2 – Purple: triggered events\nxmlParts.push(\n  '        <mxCell id=\"legend_purple\" value=\"' +\n    esc(\"Purple – Triggered events\") +\n    '\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;fillColor=#e0c9ff;\" vertex=\"1\" parent=\"1\">',\n  '          <mxGeometry x=\"' +\n    legendX +\n    '\" y=\"' +\n    legendRowY(2) +\n    '\" width=\"' +\n    legendWidth +\n    '\" height=\"' +\n    legendRowHeight +\n    '\" as=\"geometry\"/>',\n  \"        </mxCell>\"\n);\n\n// Row 3 – Grey: system/background\nxmlParts.push(\n  '        <mxCell id=\"legend_grey\" value=\"' +\n    esc(\"Grey – System/background tasks\") +\n    '\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;fillColor=#f0f0f0;\" vertex=\"1\" parent=\"1\">',\n  '          <mxGeometry x=\"' +\n    legendX +\n    '\" y=\"' +\n    legendRowY(3) +\n    '\" width=\"' +\n    legendWidth +\n    '\" height=\"' +\n    legendRowHeight +\n    '\" as=\"geometry\"/>',\n  \"        </mxCell>\"\n);\n\n// Row 4 – Orange: conditional path before triggered event (LAST in key)\nxmlParts.push(\n  '        <mxCell id=\"legend_orange\" value=\"' +\n    esc(\"Orange line – Conditional path before triggered event\") +\n    '\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;verticalAlign=middle;fillColor=#ffe0bf;\" vertex=\"1\" parent=\"1\">',\n  '          <mxGeometry x=\"' +\n    legendX +\n    '\" y=\"' +\n    legendRowY(4) +\n    '\" width=\"' +\n    legendWidth +\n    '\" height=\"' +\n    legendRowHeight +\n    '\" as=\"geometry\"/>',\n  \"        </mxCell>\"\n);\n\n// ---------------------------------------------------------\n// Edges\n//  - Normal (downward / same-level): obstacle-avoiding orthogonal\n//  - Upward (to a task above): go out to the right side lane then up\n//  - Orange if: edge has a label AND target is a triggered event\n//  - Condition text shown on the line (edge.label)\n// ---------------------------------------------------------\nedges.forEach((edge, idx) => {\n  const fromId = String(edge.from);\n  const toId = String(edge.to);\n\n  const fromCell = resolve(fromId);\n  const toCell = resolve(toId);\n  if (!fromCell || !toCell) {\n    return;\n  }\n\n  const fromNode = nodeById[fromId];\n  const toNode = nodeById[toId];\n  const fromPos = fromNode ? nodePositions[fromNode.id] : null;\n  const toPos = toNode ? nodePositions[toNode.id] : null;\n\n  const fromLevel = fromNode && levelMap[fromNode.id] !== undefined ? levelMap[fromNode.id] : 0;\n  const toLevel = toNode && levelMap[toNode.id] !== undefined ? levelMap[toNode.id] : 0;\n\n  const rawEdgeLabel = (edge.label || \"\").trim();\n  const label = esc(edge.label || \"\"); // this is what shows on the line\n\n  let style = [\n    \"edgeStyle=orthogonalEdgeStyle\",\n    \"orthogonalLoop=1\",\n    \"orthogonalRouting=1\",\n    \"avoidObstacle=1\",\n    \"jettySize=auto\",\n    \"html=1\",\n    \"rounded=0\",\n    \"endArrow=block\",\n    \"exitX=0.5\",\n    \"exitY=1\",\n    \"exitPerimeter=1\",\n    \"entryX=0.5\",\n    \"entryY=0\",\n    \"entryPerimeter=1\",\n    \"portConstraint=northsouth\",\n    \"jumpStyle=arc\",\n    \"jumpSize=6\",\n    // make the condition text readable on the line\n    \"labelBackgroundColor=#ffffff\"\n  ].join(\";\");\n\n  // Orange if:\n  // - edge has a label/condition\n  // - target is a triggered event (action type contains \"trigger\")\n  if (toNode && rawEdgeLabel) {\n    const toLines = String(toNode.label || String(toNode.id)).split(\"\\n\");\n    const toActionType = getActionTypeFromLines(toLines);\n    const isTriggered = String(toActionType || \"\").toLowerCase().includes(\"trigger\");\n    if (isTriggered) {\n      style += \";strokeColor=#ff9900\"; // orange line\n    }\n  }\n\n  // If we can't position nodes, just draw a normal edge\n  if (!fromPos || !toPos) {\n    xmlParts.push(\n      '        <mxCell id=\"edge_' +\n        idx +\n        '\" value=\"' +\n        label +\n        '\" style=\"' +\n        style +\n        '\" edge=\"1\" parent=\"1\" source=\"' +\n        fromCell +\n        '\" target=\"' +\n        toCell +\n        '\">',\n      '          <mxGeometry relative=\"1\" as=\"geometry\"/>',\n      \"        </mxCell>\"\n    );\n    return;\n  }\n\n  const isUpward = toLevel < fromLevel;\n\n  if (!isUpward) {\n    // Normal downward / same-level edge: let mxGraph route with obstacle avoidance\n    xmlParts.push(\n      '        <mxCell id=\"edge_' +\n        idx +\n        '\" value=\"' +\n        label +\n        '\" style=\"' +\n        style +\n        '\" edge=\"1\" parent=\"1\" source=\"' +\n        fromCell +\n        '\" target=\"' +\n        toCell +\n        '\">',\n      '          <mxGeometry relative=\"1\" as=\"geometry\"/>',\n      \"        </mxCell>\"\n    );\n  } else {\n    // Upward edge: route to the right side lane, then vertically, then back to target\n    const fromBottomY = fromPos.y + baseHeight;\n    const toTopY = toPos.y;\n\n    const laneX = sideBaseX + upwardEdgeCount * sideLaneSpacing;\n    upwardEdgeCount++;\n\n    const pointsXml = [\n      '            <Array as=\"points\">',\n      // go right from the bottom of the source\n      '              <mxPoint x=\"' + laneX + '\" y=\"' + fromBottomY + '\"/>',\n      // then go vertically to the top level of the target\n      '              <mxPoint x=\"' + laneX + '\" y=\"' + toTopY + '\"/>',\n      \"            </Array>\"\n    ];\n\n    xmlParts.push(\n      '        <mxCell id=\"edge_' +\n        idx +\n        '\" value=\"' +\n        label +\n        '\" style=\"' +\n        style +\n        '\" edge=\"1\" parent=\"1\" source=\"' +\n        fromCell +\n        '\" target=\"' +\n        toCell +\n        '\">',\n      '          <mxGeometry relative=\"1\" as=\"geometry\">',\n      ...pointsXml,\n      \"          </mxGeometry>\",\n      \"        </mxCell>\"\n    );\n  }\n});\n\n// ---------------------------------------------------------\nxmlParts.push(\n  \"      </root>\",\n  \"    </mxGraphModel>\",\n  \"  </diagram>\",\n  \"</mxfile>\"\n);\n\nconst xml = xmlParts.join(\"\\n\");\nconst base64 = Buffer.from(xml, \"utf8\").toString(\"base64\");\n\nreturn [\n  {\n    json: data,\n    binary: {\n      data: {\n        data: base64,\n        fileName: \"workflow_auto_spaced.drawio\",\n        mimeType: \"application/xml\",\n      },\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        440,
        0
      ],
      "id": "82570257-2c4a-4230-b3d9-fbc6248e432c",
      "name": "Transform file to draw.io"
    }
  ],
  "connections": {
    "On form submission": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Transform file to draw.io",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {},
  "versionId": "adb5257b-cbe2-4954-8e6f-2302fbde3297",
  "triggerCount": 0,
  "tags": []
}